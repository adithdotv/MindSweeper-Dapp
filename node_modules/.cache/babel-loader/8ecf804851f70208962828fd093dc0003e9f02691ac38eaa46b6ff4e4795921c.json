{"ast":null,"code":"import { WebSocket } from 'isows';\nimport { HttpRequestError, TimeoutError, WebSocketRequestError } from '../errors/request.js';\nimport { createBatchScheduler } from './promise/createBatchScheduler.js';\nimport { withTimeout } from './promise/withTimeout.js';\nimport { stringify } from './stringify.js';\nlet id = 0;\nasync function http(url, {\n  body,\n  fetchOptions = {},\n  timeout = 10000\n}) {\n  const {\n    headers,\n    method,\n    signal: signal_\n  } = fetchOptions;\n  try {\n    const response = await withTimeout(async ({\n      signal\n    }) => {\n      const response = await fetch(url, {\n        ...fetchOptions,\n        body: Array.isArray(body) ? stringify(body.map(body => ({\n          jsonrpc: '2.0',\n          id: body.id ?? id++,\n          ...body\n        }))) : stringify({\n          jsonrpc: '2.0',\n          id: body.id ?? id++,\n          ...body\n        }),\n        headers: {\n          ...headers,\n          'Content-Type': 'application/json'\n        },\n        method: method || 'POST',\n        signal: signal_ || (timeout > 0 ? signal : undefined)\n      });\n      return response;\n    }, {\n      errorInstance: new TimeoutError({\n        body,\n        url\n      }),\n      timeout,\n      signal: true\n    });\n    let data;\n    if (response.headers.get('Content-Type')?.startsWith('application/json')) {\n      data = await response.json();\n    } else {\n      data = await response.text();\n    }\n    if (!response.ok) {\n      throw new HttpRequestError({\n        body,\n        details: stringify(data.error) || response.statusText,\n        headers: response.headers,\n        status: response.status,\n        url\n      });\n    }\n    return data;\n  } catch (err) {\n    if (err instanceof HttpRequestError) throw err;\n    if (err instanceof TimeoutError) throw err;\n    throw new HttpRequestError({\n      body,\n      details: err.message,\n      url\n    });\n  }\n}\nexport const socketsCache = /*#__PURE__*/new Map();\nexport async function getSocket(url) {\n  let socket = socketsCache.get(url);\n  // If the socket already exists, return it.\n  if (socket) return socket;\n  const {\n    schedule\n  } = createBatchScheduler({\n    id: url,\n    fn: async () => {\n      const webSocket = new WebSocket(url);\n      // Set up a cache for incoming \"synchronous\" requests.\n      const requests = new Map();\n      // Set up a cache for subscriptions (eth_subscribe).\n      const subscriptions = new Map();\n      const onMessage = ({\n        data\n      }) => {\n        const message = JSON.parse(data);\n        const isSubscription = message.method === 'eth_subscription';\n        const id = isSubscription ? message.params.subscription : message.id;\n        const cache = isSubscription ? subscriptions : requests;\n        const callback = cache.get(id);\n        if (callback) callback({\n          data\n        });\n        if (!isSubscription) cache.delete(id);\n      };\n      const onClose = () => {\n        socketsCache.delete(url);\n        webSocket.removeEventListener('close', onClose);\n        webSocket.removeEventListener('message', onMessage);\n      };\n      // Setup event listeners for RPC & subscription responses.\n      webSocket.addEventListener('close', onClose);\n      webSocket.addEventListener('message', onMessage);\n      // Wait for the socket to open.\n      if (webSocket.readyState === WebSocket.CONNECTING) {\n        await new Promise((resolve, reject) => {\n          if (!webSocket) return;\n          webSocket.onopen = resolve;\n          webSocket.onerror = reject;\n        });\n      }\n      // Create a new socket instance.\n      socket = Object.assign(webSocket, {\n        requests,\n        subscriptions\n      });\n      socketsCache.set(url, socket);\n      return [socket];\n    }\n  });\n  const [_, [socket_]] = await schedule();\n  return socket_;\n}\nfunction webSocket(socket, {\n  body,\n  onResponse\n}) {\n  if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING) throw new WebSocketRequestError({\n    body,\n    url: socket.url,\n    details: 'Socket is closed.'\n  });\n  const id_ = id++;\n  const callback = ({\n    data\n  }) => {\n    const message = JSON.parse(data);\n    if (typeof message.id === 'number' && id_ !== message.id) return;\n    onResponse?.(message);\n    // If we are subscribing to a topic, we want to set up a listener for incoming\n    // messages.\n    if (body.method === 'eth_subscribe' && typeof message.result === 'string') {\n      socket.subscriptions.set(message.result, callback);\n    }\n    // If we are unsubscribing from a topic, we want to remove the listener.\n    if (body.method === 'eth_unsubscribe') {\n      socket.subscriptions.delete(body.params?.[0]);\n    }\n  };\n  socket.requests.set(id_, callback);\n  socket.send(JSON.stringify({\n    jsonrpc: '2.0',\n    ...body,\n    id: id_\n  }));\n  return socket;\n}\nasync function webSocketAsync(socket, {\n  body,\n  timeout = 10000\n}) {\n  return withTimeout(() => new Promise(onResponse => rpc.webSocket(socket, {\n    body,\n    onResponse\n  })), {\n    errorInstance: new TimeoutError({\n      body,\n      url: socket.url\n    }),\n    timeout\n  });\n}\n///////////////////////////////////////////////////\nexport const rpc = {\n  http,\n  webSocket,\n  webSocketAsync\n};","map":{"version":3,"names":["WebSocket","HttpRequestError","TimeoutError","WebSocketRequestError","createBatchScheduler","withTimeout","stringify","id","http","url","body","fetchOptions","timeout","headers","method","signal","signal_","response","fetch","Array","isArray","map","jsonrpc","undefined","errorInstance","data","get","startsWith","json","text","ok","details","error","statusText","status","err","message","socketsCache","Map","getSocket","socket","schedule","fn","webSocket","requests","subscriptions","onMessage","JSON","parse","isSubscription","params","subscription","cache","callback","delete","onClose","removeEventListener","addEventListener","readyState","CONNECTING","Promise","resolve","reject","onopen","onerror","Object","assign","set","_","socket_","onResponse","CLOSED","CLOSING","id_","result","send","webSocketAsync","rpc"],"sources":["C:\\Users\\HP\\Desktop\\wEB3\\somnia\\node_modules\\viem\\utils\\rpc.ts"],"sourcesContent":["import { WebSocket } from 'isows'\nimport type { MessageEvent } from 'isows'\n\nimport {\n  HttpRequestError,\n  type HttpRequestErrorType,\n  TimeoutError,\n  type TimeoutErrorType,\n  WebSocketRequestError,\n} from '../errors/request.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport {\n  type CreateBatchSchedulerErrorType,\n  createBatchScheduler,\n} from './promise/createBatchScheduler.js'\nimport {\n  type WithTimeoutErrorType,\n  withTimeout,\n} from './promise/withTimeout.js'\nimport { stringify } from './stringify.js'\n\nlet id = 0\n\ntype SuccessResult<T> = {\n  method?: never\n  result: T\n  error?: never\n}\ntype ErrorResult<T> = {\n  method?: never\n  result?: never\n  error: T\n}\ntype Subscription<TResult, TError> = {\n  method: 'eth_subscription'\n  error?: never\n  result?: never\n  params: {\n    subscription: string\n  } & (\n    | {\n        result: TResult\n        error?: never\n      }\n    | {\n        result?: never\n        error: TError\n      }\n  )\n}\n\nexport type RpcRequest = { method: string; params?: any; id?: number }\n\nexport type RpcResponse<TResult = any, TError = any> = {\n  jsonrpc: `${number}`\n  id: number\n} & (\n  | SuccessResult<TResult>\n  | ErrorResult<TError>\n  | Subscription<TResult, TError>\n)\n\n///////////////////////////////////////////////////\n// HTTP\n\nexport type HttpOptions<TBody extends RpcRequest | RpcRequest[] = RpcRequest> =\n  {\n    // The RPC request body.\n    body: TBody\n    // Request configuration to pass to `fetch`.\n    fetchOptions?: Omit<RequestInit, 'body'>\n    // The timeout (in ms) for the request.\n    timeout?: number\n  }\n\nexport type HttpReturnType<\n  TBody extends RpcRequest | RpcRequest[] = RpcRequest,\n> = TBody extends RpcRequest[] ? RpcResponse[] : RpcResponse\n\nexport type HttpErrorType =\n  | HttpRequestErrorType\n  | TimeoutErrorType\n  | WithTimeoutErrorType\n  | ErrorType\n\nasync function http<TBody extends RpcRequest | RpcRequest[]>(\n  url: string,\n  { body, fetchOptions = {}, timeout = 10_000 }: HttpOptions<TBody>,\n): Promise<HttpReturnType<TBody>> {\n  const { headers, method, signal: signal_ } = fetchOptions\n  try {\n    const response = await withTimeout(\n      async ({ signal }) => {\n        const response = await fetch(url, {\n          ...fetchOptions,\n          body: Array.isArray(body)\n            ? stringify(\n                body.map((body) => ({\n                  jsonrpc: '2.0',\n                  id: body.id ?? id++,\n                  ...body,\n                })),\n              )\n            : stringify({ jsonrpc: '2.0', id: body.id ?? id++, ...body }),\n          headers: {\n            ...headers,\n            'Content-Type': 'application/json',\n          },\n          method: method || 'POST',\n          signal: signal_ || (timeout > 0 ? signal : undefined),\n        })\n        return response\n      },\n      {\n        errorInstance: new TimeoutError({ body, url }),\n        timeout,\n        signal: true,\n      },\n    )\n\n    let data\n    if (response.headers.get('Content-Type')?.startsWith('application/json')) {\n      data = await response.json()\n    } else {\n      data = await response.text()\n    }\n\n    if (!response.ok) {\n      throw new HttpRequestError({\n        body,\n        details: stringify(data.error) || response.statusText,\n        headers: response.headers,\n        status: response.status,\n        url,\n      })\n    }\n\n    return data\n  } catch (err) {\n    if (err instanceof HttpRequestError) throw err\n    if (err instanceof TimeoutError) throw err\n    throw new HttpRequestError({\n      body,\n      details: (err as Error).message,\n      url,\n    })\n  }\n}\n\n///////////////////////////////////////////////////\n// WebSocket\n\ntype Id = string | number\ntype CallbackFn = (message: any) => void\ntype CallbackMap = Map<Id, CallbackFn>\n\nexport type Socket = WebSocket & {\n  requests: CallbackMap\n  subscriptions: CallbackMap\n}\n\nexport type GetSocketErrorType = CreateBatchSchedulerErrorType | ErrorType\n\nexport const socketsCache = /*#__PURE__*/ new Map<string, Socket>()\n\nexport async function getSocket(url: string) {\n  let socket = socketsCache.get(url)\n\n  // If the socket already exists, return it.\n  if (socket) return socket\n\n  const { schedule } = createBatchScheduler<undefined, [Socket]>({\n    id: url,\n    fn: async () => {\n      const webSocket = new WebSocket(url)\n\n      // Set up a cache for incoming \"synchronous\" requests.\n      const requests = new Map<Id, CallbackFn>()\n\n      // Set up a cache for subscriptions (eth_subscribe).\n      const subscriptions = new Map<Id, CallbackFn>()\n\n      const onMessage: (event: MessageEvent) => void = ({ data }) => {\n        const message: RpcResponse = JSON.parse(data as string)\n        const isSubscription = message.method === 'eth_subscription'\n        const id = isSubscription ? message.params.subscription : message.id\n        const cache = isSubscription ? subscriptions : requests\n        const callback = cache.get(id)\n        if (callback) callback({ data })\n        if (!isSubscription) cache.delete(id)\n      }\n      const onClose = () => {\n        socketsCache.delete(url)\n        webSocket.removeEventListener('close', onClose)\n        webSocket.removeEventListener('message', onMessage)\n      }\n\n      // Setup event listeners for RPC & subscription responses.\n      webSocket.addEventListener('close', onClose)\n      webSocket.addEventListener('message', onMessage)\n\n      // Wait for the socket to open.\n      if (webSocket.readyState === WebSocket.CONNECTING) {\n        await new Promise((resolve, reject) => {\n          if (!webSocket) return\n          webSocket.onopen = resolve\n          webSocket.onerror = reject\n        })\n      }\n\n      // Create a new socket instance.\n      socket = Object.assign(webSocket, {\n        requests,\n        subscriptions,\n      })\n      socketsCache.set(url, socket)\n\n      return [socket]\n    },\n  })\n\n  const [_, [socket_]] = await schedule()\n  return socket_\n}\n\nexport type WebSocketOptions = {\n  /** The RPC request body. */\n  body: RpcRequest\n  /** The callback to invoke on response. */\n  onResponse?: (message: RpcResponse) => void\n}\n\nexport type WebSocketReturnType = Socket\n\nexport type WebSocketErrorType = WebSocketRequestError | ErrorType\n\nfunction webSocket(\n  socket: Socket,\n  { body, onResponse }: WebSocketOptions,\n): WebSocketReturnType {\n  if (\n    socket.readyState === socket.CLOSED ||\n    socket.readyState === socket.CLOSING\n  )\n    throw new WebSocketRequestError({\n      body,\n      url: socket.url,\n      details: 'Socket is closed.',\n    })\n\n  const id_ = id++\n\n  const callback = ({ data }: { data: any }) => {\n    const message: RpcResponse = JSON.parse(data)\n\n    if (typeof message.id === 'number' && id_ !== message.id) return\n\n    onResponse?.(message)\n\n    // If we are subscribing to a topic, we want to set up a listener for incoming\n    // messages.\n    if (body.method === 'eth_subscribe' && typeof message.result === 'string') {\n      socket.subscriptions.set(message.result, callback)\n    }\n\n    // If we are unsubscribing from a topic, we want to remove the listener.\n    if (body.method === 'eth_unsubscribe') {\n      socket.subscriptions.delete(body.params?.[0])\n    }\n  }\n  socket.requests.set(id_, callback)\n\n  socket.send(JSON.stringify({ jsonrpc: '2.0', ...body, id: id_ }))\n\n  return socket\n}\n\nexport type WebSocketAsyncOptions = {\n  /** The RPC request body. */\n  body: RpcRequest\n  /** The timeout (in ms) for the request. */\n  timeout?: number\n}\n\nexport type WebSocketAsyncReturnType = RpcResponse\n\nexport type WebSocketAsyncErrorType =\n  | WebSocketErrorType\n  | TimeoutErrorType\n  | WithTimeoutErrorType\n  | ErrorType\n\nasync function webSocketAsync(\n  socket: Socket,\n  { body, timeout = 10_000 }: WebSocketAsyncOptions,\n): Promise<WebSocketAsyncReturnType> {\n  return withTimeout(\n    () =>\n      new Promise<RpcResponse>((onResponse) =>\n        rpc.webSocket(socket, {\n          body,\n          onResponse,\n        }),\n      ),\n    {\n      errorInstance: new TimeoutError({ body, url: socket.url }),\n      timeout,\n    },\n  )\n}\n\n///////////////////////////////////////////////////\n\nexport const rpc = {\n  http,\n  webSocket,\n  webSocketAsync,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}